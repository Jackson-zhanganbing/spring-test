各位同事，大家好，今天我给大家分享一下软件开发中的设计模式。

==================================背景
首先，聊一下设计模式的背景，设计模式最早是产生与建筑领域，当时有个很著名的建筑大师：克里斯托夫·亚历山大，写了本书《建筑模式语言：城镇、建筑、构造》，描述了一些常见的建筑设计问题，提出了253种建筑领域的设计模式。
在软件行业呢，设计模式最早是由四人组：艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides） 这四人于1990年在他们的合著《设计模式：可复用面向对象软件的基础》中提到，这本书一共收录了23中设计模式，被认为是软件开发领域设计模式的里程碑事件，导致了软件设计模式的突破。
我们主要也是学习这23中设计模式

==================================UML（Unified Modeling Language） 图
聊完设计模式的背景，咱们一起看看设计模式的一些基础，因为设计模式都是一些接口、抽象类、普通类组合来组合去，所以我们必须知道类和类、类和接口之间的一些关系。
一共有六种关系： 分别是：继承、实现、依赖、关联、聚合、组合
继承比较好理解，就是父类和子类之间的关系，子类通过继承可以（免费）获得父类的一些方法和属性。
继承的两个类之间用空心三角形和实线连接

实现也很简单，就是接口和实现类的关系，实现用空心三角形和虚线连接

依赖，这种关系，主要是某个类中使用了另一个类，举个例子，dog要吃食物，所以依赖了Food，Food和Dog之间没有强依赖，Food是不是也可以给人吃啊，当然了，狗粮是不能给人吃的哈，但是food可以是肉，大家都能吃，没有特别的绑定关系
依赖用虚线和箭头连接

比依赖关系更强烈的是关联，关联的关系一般是长期的，比如老师和课程，老师一般都会给学生上课，都会和课程强关联，课程不能给dog来上吧？不能给其他职业来上吧，当然也可以，比如医生，但是上课的医生，是不是也同时是一个老师。
关联用实现和箭头连接

比关联关系依赖更强的是聚合，聚合可以用has-a来描述，比如车和轮胎的关系，可以说，车有一个轮胎；比如，笔记本和键盘的关系，可以说笔记本有一个键盘。
聚合用空心菱形、实线和箭头连接

那么比聚合关系更强的关系就是组合了，区分聚合和组合，最重要的就是生命周期，组合各个类之间有相同的生命周期，聚合则不一定。比如，人和头的关系，人没了，现目前的科技来说，头不能单独用；但是你想想，轮胎可以吗？车报废了，发动机和变速箱甚至底盘都坏了，但是哎，这个轮胎是好的，还可以装到其他车上去用，当然，size要合适才行。
组合用实心菱形、实现和箭头连接

说完这些关系，我们看看类和接口怎么表示
一般，我们把接口或者类画成一个方框，用两根横线分成三块：

最上面这块，写接口或者类的名字，如果是接口还需要在接口名上面写上interface，用双书名号括起来
中间这块写属性，结构是： 访问修饰符（+、-、#）、属性名、冒号、属性类型。
最下面这块写方法，结构是：访问权限、方法名、方法参数、冒号、返回类型

+：表示public
-：表示private
#：表示protect
没有就表示default权限



==================================设计原则
明白了uml图怎么画后，我们就可以开始了解什么是软件设计原则了，软件设计有六大原则。
分别是：
单一职责原则、接口隔离原则、开闭原则、里氏替换原则、依赖倒置原则、迪米特法则

首先介绍一下单一职责原则，它的定义不易理解，它是这样定义的：一个类仅有一个引起它变化的原因。换句话讲就容易理解了：一个类应该只负责一项职责。下面我们看一下案例：
案例中我们定义了一个Report类，有几个方法：分别是生成报告：generateReport、保存到文件saveToFile、打印print，其实这种不合理的设计到处都有，最主要思想的就是职责划分。那一个符合单一原则的设计就像下面这样：
把报告的保存和报告的打印分别用一个类来实现。我们用ReportSaver来保存文件，用ReportPrinter来打印报告，在使用保存或者打印的地方直接用这两个类就好

那下面我们看下接口隔离原则，定义是这样：客户端不应该被迫依赖它不需要的接口；这里的接口，不局限于java中的interface关键字，泛指接口、类、方法等等客户端依赖的各种元素，强调的是客户端依赖的范围不能被强加一些不需要的。
咱们换种说法就好理解了：
一个接口设计的时候只包含实现类需要的方法。
下面我们看个案例，一种不符合接口隔离原则的设计，这里有个Animal，有吃、飞、游三个方法，分别有Dog和Fish去实现，但是由于Animal接口被强加了一些客户端不需要的方法，导致狗和鱼在实现接口的时候，Fly方法只能抛异常
那我们符合接口隔离原则的设计怎么做呢？其实就是把方法抽出来，比如eat，独立成Eater接口，swim独立成Swimmer，这样Dog就可以实现自己需要的吃和游的方法。

SRP VS LSP
那其实有时候这三个方法是有可能在一起的，比如要实现一只水鸟的接口，那就有可能吃、飞、游都有，按照单一职责原则，是可以把这三个方法写到一个类中的，但是按照接口隔离原则，这个类的interface还需要细分。
这里我们也可以看出来，单一职责原则强调的是类的职责，接口隔离原则重在接口的设计，SRP是把功能拆分成多个类，LSP呢，是把接口细分，让实现类可以灵活实现自己需要的接口。

下面介绍一下开闭原则，它的定义就非常清晰，面向扩展开放，面向修改关闭。什么意思呢？我们看个案例
这里有个面积计算器的类，支持输入形状计算面积，现在已经支持圆形和长方形了。因为都是用if、else写的，所以支持其他形状需要我们改变这段代码。
这就是面向修改开放了，我们要做到支持新功能的时候，原来的代码不发生变化或者发生微小变化，应该怎么做呢？
我们把计算面积的方法封装到形状里就行了，比如这里的Circle里有个获取面积的方法，公式写area里，π*r平方，面积计算器呢，还是支持传一个形状，但是计算面积的方法，交给形状了
这样，我们支持其他形状计算面积的方法时，只需要增加一个类，类中自行封装计算方法，原来的代码不受影响。

下面我们学习里氏替换原则，这个原则的定义是：如果对每一个类型为S的对象o1，都有类型为T的对
象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型
哈哈，初次接触，非常难以理解，一般我们看另一种表述即可，说啊：所有引用基类的地方都必须能透明地使用其子类的对象而不会破坏原程序的正确性
举个例子就清楚了：
这里定义了一个Bird的类，让麻雀和企鹅去继承并实现其相关方法，但是企鹅不会飞，这里就抛一个异常，那么在main方法中，当这个Bird类
被new成企鹅的时候，就会报错，或者这么理解，当一个方法，比如A方法，中传入的参数就是Bird，A方法中调用了fly方法，这个A方法的Bird可以随意传任何Bird的子类吗？
我们这个案例不能吧？传入penguin就要报错呢，不符合：所有引用基类的地方都必须能透明地使用其子类的对象而不会破坏原程序的正确性
那我们符合里氏替换的做法是这样的：把麻雀和企鹅共同的方法抽成同一个接口，让麻雀再去实现一个新接口：FlyingBird，接口里就有fly方法
这样当我们用LspBird的地方都可以随意使用麻雀和企鹅了。

下面介绍一下依赖倒置原则，它的含义是：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
其实这个原则咱们写业务代码时都在用，高层Controller一般会依赖一个service的接口，而不是直接依赖service的实现。我举个例子：
你看这个的DataProcessor直接依赖了FileManager，这就非常不合适，符合依赖倒置原则的写法应该是把文件保存抽象出一个接口
比如DataSaver，文件存储只是一方面，即使目前实现就一个，但是也应该依赖接口，方便以后扩展，这里举了一个数据库存储的类，让DataSever有了更多的一个选择
这里稍微解释下何为倒置？相比于传统，高层模块直接依赖低层模块，这个原则让低层模块依赖接口，高层模块依赖低层的接口，对于依赖的目标来说就是被倒置了。

下面介绍一下迪米特法则，这个法则说的是：一个类/模块对其他的类/模块了解得越少越好
这个法则，我们也看一个案例
这是一个电商系统的案例，有一个订单Order，一个顾客类Customer，一个地址类Address，订单想要获取邮编，所以依赖了顾客，顾客依赖了地址，顾客里有一个方法就是获取地址，
在通过顾客里的地址去获取邮编，那么在订单类中就会关联到地址这个类，实际上订单并不关心这个类，只需要邮编即可，所以我们符合迪米特法则的写法就是把获取邮编的方法封装起来
放到顾客类中，这样在order类中就不会用到Address了。减少了类对其他类的依赖

==================设计模式
在了解了UML图、六大设计原则后，我们终于可以学习具体的设计模式了。设计模式一共分为三大类，分别是：
创建型、行为型、结构型
==========创建型设计模式
首先聊一下创建型，创建型分为：单例、工厂、抽象工厂、原型、建造者这五种
=====单例模式
单例模式的目标就是让一个类只有一个对象，为了达到这个目标，单例模式诞生了很多种写法
我们先看类图，类图很简单，有一个Singleton类，类中有一个获取实例的方法，类中有个属性就是自身。
然后就是测试类依赖这个类，就这样。
我们看看代码，单例模式有懒汉式、饿汉式、懒汉式安全型、饿汉式双检锁型、枚举型、静态内部类等等多种
先看懒汉式：它的主要特点是在调用方法时去new实例，获取实例方法很简单，就是判断属性instance是不是为空，不为空就new，为空直接返回。
懒汉式线程不安全。
所以为了解决线程安全性问题，诞生了另一种写法：在方法上加上synchronized。
线程安全的懒汉式，解决了并发安全问题，但是性能受到影响。为此诞生了双检锁的写法：这种写法在内部代码块中加上了锁，解决安全性问题的同时又不损耗性能。
不考虑空间，保证安全的方式，就诞生了饿汉式，这种写法主要特点就是安全，但是可能造成资源浪费，就是如果没有人使用该类的单例时，也会有对象存在内存中。
静态内部类的方式，类似于饿汉式。
但是，不管是双检锁懒汉式，还是直接new的饿汉式，
这就一定能保证单例吗？假如我们用反射呢？能不能获取一个新对象？
所以，有一种终极的单例就是枚举型单例模式，这种单例能够阻止反射创建新的重复对象。
写法就是一个枚举而已。大家要知道有这些类型即可。工作中，多线程需要获取统一对象时，可以用上单例模式。比如线程池、数据库连接池等

=====工厂模式

工厂模式的目标就是要生产对象，又分几种类型，有简单工厂、工厂模式、抽象工厂模式
===简单工厂
简单工厂，严格说不算一种设计模式，代码很简单，根据传的类型，生产对象。案例中有ACar和BCar两种车，分别有brand和vin两个字段
我们在测试类中跑一下结果，可以看到长安123跑起来了，SL321跑起来了。测试类中我们不关心类怎么创建的，只知道给一个A类型，工厂就给我ACar；
给个B类型，工厂就给我BCar，实际上这就是工厂模式的核心，封装对象的创建过程。
===工厂模式
简单工厂其实根据我们之前学过的设计原则，它不符合哪个原则呢？是不是工厂内部不符合开闭原则呀？当我需要新类型的时候，我还得修改工厂的创建方法。
我们看下工厂模式的类图：
首先是要生产的产品，我们是造车的，所以这里生产的车，有一个ICar接口，跟简单工厂一样，有ACar和BCar，字段也是brand和vin，还有个工厂接口，分别有两个实现
ACarFactory和BCarFactory，工厂就一个方法：createProduct
我们看下代码：
实际上在A工厂内部createProduct里，就是把对象new出来而已，B工厂类似，只不过生产的深蓝
我们看下测试类，需要车的时候，我们就把工厂new出来，然后用对应的工厂去创建这个车。
===抽象工厂模式
工厂模式解决了简单工厂不符合开闭原则的问题，单独用一个工厂去创建新的类型的车，但是无法解决创建复杂对象的情况。
抽象工厂正好出现解决复杂对象的创建，我们看下类图：
这里我举了一个煎饼果子的案例，现在有煎饼接口（IPanCake）和肉松接口（IMeatfloss）
煎饼分别有Corn/kɔːn/玉米煎饼和小麦wheat/wiːt/煎饼，肉松分为鸡肉chicken肉松和猪肉pork肉松
还有个创建煎饼果子的接口，煎饼果子暂且由煎饼和肉松组成，不比真实的复杂啊，你吃过的可能还有培根，香肠、生菜等等。
在我这只有煎饼和肉松基础款，然后这个煎饼果子的接口暂且只有鸡肉松玉米煎饼组成和猪肉松小麦煎饼组成。
我们看下代码：
煎饼有名字和热量两个字段，肉松同样。
于是我们通过猪肉肉松小麦煎饼的抽象工厂创建了一个煎饼果子，通过鸡肉松玉米煎饼的抽象工厂创建了另一个煎饼果子，两个煎饼果子各有千秋
抽象工厂主要解决工厂模式只能创建单一产品的局限性，抽象二字可以这么去理解，创建的产品是多元的抽象的，比如这种鸡肉松玉米煎饼组成的东西。

=====原型模式
原型模式主要目标是复制一个一模一样的对象出来
我们看下类图：
很简单，就是有个ProtoClass实现了一个接口Prototype，接口定义了一个clone方法，可以克隆自己
看下代码：
ProtoClass有id和name两个属性，cloneProtoType这个方法就是把ProtoClass类中的字段复制一份新创建一个类。
我们跑一下测试类：通过cloneProtoType获得的类，地址和原来的类是完全不一样的。
原型模式主要用于频繁创建对象的情形。

=====建造者模式
建造者模式主要目的就是创建复杂对象，它把对象的创建和表示分开了
我们先看下类图，要创建的就是这个House类，有墙walls、roof屋顶、doorz门
house的创建者有创建墙的buildWalls、创建屋顶的buildRoof、创建门的buildDoors，还有个获取创建成品的getResult
接口定义了这些方法，有个具体实现类WoodenHouseBuilder，最后还有个指挥者，指挥具体建造者创建房子

我们看下代码：
接口没什么好说的，创建墙、房顶、门，获取房子
实现类也很简单，就是简单的加属性，实际房子建设会很复杂。
建造者实际上是不知道建造顺序的，这里有一个指挥者，告诉建造者建造顺序
最后，我们看下测试案例
指挥者，指挥建造者建造房子的顺序，最后从建造者手中获取了一个完美的木屋房子。


==========行为型设计模式
以上就是所有创建型设计模式了，下面我们学习行为型设计模式
行为型设计模式，它主要关注对象之间的交互和责任分配，不管是交互还是责任都属于对象的行为，主要有：命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式
观察者模式、责任链模式、状态模式、策略模式、模板方法模式、访问者模式

=====命令模式
我们先看下命令模式，刚刚提到行为型摄模式主要关注对象之间的交互和责任分配，带着这个前提来看看命令模式的类图：
首先有个汽车命令的接口，接口只有一个执行命令的方法，有三种指令，分别是brake、start和stop指令，指令都会接收汽车类
指令类真正执行指令时，是调用的Car中的具体方法。除了指令和汽车，还有个指令调用器，调用器可以设置指令和调用指令
好，类图看完，我们看下代码：
代码主要看看指令调用器，调用器设置命令，执行命令
测试类中，我们先new了一个car，car中是有三个真实的汽车动作。然后new三个指令，用指令调用器设置一个，执行一个。但其实最终都会执行到汽车的真实动作上
那，命令模式把类的交互整这么复杂的目的是什么呢？你想，我有一个类Car有三个动作，我再搞了三个类去封装三个真实动作的执行，然后再用调用器设置命令，执行命令
这其实很复杂，为什么不用car直接调用真实动作呢？还是重复最开始说的，行为型模式主要关注对象之间的交互和责任分配
我们这么做，1、可以把请求封装起来，使得命令可以被带走、被存储、被传递；2、调用者和执行者解耦了，调用者可以不关注命令细节，只需调用命令对象的execute
3、还有这么做也遵循了开闭原则，新的指令来了，也不用修改代码，写一个新类封装指令即可。

=====解释器模式
下面，看下解释器模式
先看类图
类图中，有一个表达式接口，表达式有解释interpret这么一个方法，表达式有三个实现，分别是加法表达式、减法表达式、数字表达式
还有一个表达式解析器，负责解析输入的字符token
具体看下代码：
表达式接口和相关实现都很简单，加法表达式就是把左右表达式加起来，减法就相减，如果是数字类型的就直接返回
在解析的时候，我们接收token字符串，对token进行空格切割，循环token数组，如果遇到数字token，就压入栈，如果遇到加法token，我们就从栈中取两个值，然后压入加法表达式
如果是减法token，我们就弹出两个值，压入减法表达式，我们知道不管什么表达式，解释的时候都是返回的数字，所以这里我们测试的时候，直接pop出栈的最后一个表达式即可
如我们测试类中的运行结果一样，答案是4

=====迭代器模式
迭代器模式，我们在工作中经常见到，任何集合都是继承了Iterable，都是可迭代的，都有基本的hasNext？ next？
那我们迭代器模式也就是这个东西了
先看类图：
有一个迭代器接口，有判断还有元素吗的一个方法hasNext和获取下一个元素的方法next，接口实现类
接口内部有装元素的list和下标字段position
看下代码
判断是否还有元素，用下标去和集合的size比较，如果下标小于集合size就说明还有元素
next就很简单，直接list获取下标++个元素就行
测试一下，我们构建了一个集合，构造到自定义迭代器里，然后开始迭代访问
案例比较简单，也可以建一个接口，让迭代对象实现，调用方法专门获取迭代器，我这里是用的构造

=====中介者模式
下面讲一下中介者模式，模式如其名啊，我们看下类图
类图中有个聊天室，只有一个方法，显示消息，输入用户和消息
还有个用户，用户中有聊天室和用户名
那这个案例非常经典，我们说过行为型模式都是些对象之间的交互和责任分配
这里的聊天室作为中介，显示各个用户发送的消息，让用户不用每个人都去发一次，减少了用户之间的耦合
是不是也符合迪米特法则啊，迪米特法则讲的就是对其他对象知道得越少越好
我们最后看下代码实现
聊天室接口，有显示聊天消息的方法
聊天室实现就是把用户名、日期和消息打印出来
用户有聊天室和用户名两个字段，发送消息就是调用聊天室显示消息
最后，我们看下测试类：
我们构造了三个用户，这也是我们熟知的三兄弟啊：张三李四王五
他们三，想要聊天，所以分别发送了一条消息，由于都在聊天室中，所以他们都能看到对方发的消息
但是他们都没有往彼此的类中传送什么消息，用户之间没有任何耦合
以上就是中介者模式

=====备忘录模式
备忘录模式
讲的是不破坏封装性的前提下，捕获一个对象的内部状态，并允许在对象之外保存和恢复这些状态。
是不是打游戏的时候有存档功能，就可以用这个模式。
我们看下类图：
这是一个非常经典的备忘录模式类图，有三个主体，备忘录，里面只有一个字符串state
有备忘录保管人，就是个备忘录列表，还有个发起人，发起人可以获取状态、设置状态、保存备忘录、从备忘录获取状态
看下代码：
这是备忘录，只有个state状态字段
保管人有备忘录列表，添加和获取备忘录方法
发起人可以保存状态到备忘录，可以恢复备忘录状态
看下测试：
new了一个发起人，发起人最开始很开心
后来，他把开心存了起来，等不开心的时候取出来开心一下
后来委屈了，难过了，他取出了备忘录中的开心
备忘录中定义中说到不破坏封装性的前提下，捕获一个对象的内部状态讲的是Originator，
我们在操作Originator对象的状态时，并未破坏它的封装性，在外部储存了它的状态，使之可以恢复状态。

=====观察者模式
观察者模式的定义：定义对象之间的一对多依赖关系，这样当一个对象改变状态时，它的所有依赖项都会自动得到通知和更新。
定义都有一点晦涩难懂，我们直接看一个类图：
右边有一个观察者接口，可以接收一些信息，这里是天气预报的信息。有两个具体观察者实现
左边有一个天气主题的接口，可以注册观察者，可以移除观察者，可以通知观察者，然后就是天气主题接口的实现了。
实现里，有温度和天气情况两个字段，还有观察者的列表。观察者可以理解为天气预报订阅者。
我们看下代码
观察者接口定义了接收天气情况和温度。观察者1实现直接打印收到的天气和气温
观察者2类似
天气主题，跟类图完全一样，注册，移除，通知观察者三个接口
主要是这个具体实现：注册就是往观察者列表observerList加人，移除就remove，通知就是循环调用注册进来的观察者的receive接口
最后，看下测试情况
new出两个观察者1和2，构造今天的天气晴、25.2度非常的宜人，注册两个观察者
然后取消观察者1，然后呢我们天气有变化，再通知呢，就只有观察者2收得到天气预报了
那这个案例其实是Head First设计模式里的经典案例，是我设计模式的启蒙书。大家有兴趣可以阅读一下。

=====责任链模式
下面我们看下责任链模式
责任链模式的定义：避免将一个请求的发送者与接收者耦合在一起,让多个对象都有机会处理请求.
将接收请求的对象连接成一条链,并且沿着这条链传递请求,直到有一个对象能够处理它为止
先看类图
左边有一个车辆检查的处理器，定义了两个方法，一个是设置下一个检查处理器，另一个是处理请求方法，
接口有两个实现，一是检查油量，一个检查胎压；右边是一个车辆类，有油量和胎压
看下代码
这是检查处理器接口，两个方法跟刚刚说的一样
这是油量检查，逻辑就是油量低于10，就让加油，否则检查下一项
胎压检查，逻辑是当胎压低于2.0就让检查是否漏气，否者进行下一项
看下测试类
我们这里构造了一辆油量是99，胎压是1.9的车，让检查器检查
然后获取一个检查责任链。责任链，先是油量再试胎压检查

运行，检查结果出来了，油量正常，胎压低了。





























