各位同事，大家好，今天我给大家分享一下软件开发中的设计模式。

==================================背景
首先，聊一下设计模式的背景，设计模式最早是产生与建筑领域，当时有个很著名的建筑大师：克里斯托夫·亚历山大，写了本书《建筑模式语言：城镇、建筑、构造》，描述了一些常见的建筑设计问题，提出了253种建筑领域的设计模式。
在软件行业呢，设计模式最早是由四人组：艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides） 这四人于1990年在他们的合著《设计模式：可复用面向对象软件的基础》中提到，这本书一共收录了23中设计模式，被认为是软件开发领域设计模式的里程碑事件，导致了软件设计模式的突破。
我们主要也是学习这23中设计模式

==================================UML（Unified Modeling Language） 图
聊完设计模式的背景，咱们一起看看设计模式的一些基础，因为设计模式都是一些接口、抽象类、普通类组合来组合去，所以我们必须知道类和类、类和接口之间的一些关系。
一共有六种关系： 分别是：继承、实现、依赖、关联、聚合、组合
继承比较好理解，就是父类和子类之间的关系，子类通过继承可以（免费）获得父类的一些方法和属性。
继承的两个类之间用空心三角形和实线连接

实现也很简单，就是接口和实现类的关系，实现用空心三角形和虚线连接

依赖，这种关系，主要是某个类中使用了另一个类，举个例子，dog要吃食物，所以依赖了Food，Food和Dog之间没有强依赖，Food是不是也可以给人吃啊，当然了，狗粮是不能给人吃的哈，但是food可以是肉，大家都能吃，没有特别的绑定关系
依赖用虚线和箭头连接

比依赖关系更强烈的是关联，关联的关系一般是长期的，比如老师和课程，老师一般都会给学生上课，都会和课程强关联，课程不能给dog来上吧？不能给其他职业来上吧，当然也可以，比如医生，但是上课的医生，是不是也同时是一个老师。
关联用实现和箭头连接

比关联关系依赖更强的是聚合，聚合可以用has-a来描述，比如车和轮胎的关系，可以说，车有一个轮胎；比如，笔记本和键盘的关系，可以说笔记本有一个键盘。
聚合用空心菱形、实线和箭头连接

那么比聚合关系更强的关系就是组合了，区分聚合和组合，最重要的就是生命周期，组合各个类之间有相同的生命周期，聚合则不一定。比如，人和头的关系，人没了，现目前的科技来说，头不能单独用；但是你想想，轮胎可以吗？车报废了，发动机和变速箱甚至底盘都坏了，但是哎，这个轮胎是好的，还可以装到其他车上去用，当然，size要合适才行。
组合用实心菱形、实现和箭头连接

说完这些关系，我们看看类和接口怎么表示
一般，我们把接口或者类画成一个方框，用两根横线分成三块：

最上面这块，写接口或者类的名字，如果是接口还需要在接口名上面写上interface，用双书名号括起来
中间这块写属性，结构是： 访问修饰符（+、-、#）、属性名、冒号、属性类型。
最下面这块写方法，结构是：访问权限、方法名、方法参数、冒号、返回类型

+：表示public
-：表示private
#：表示protect
没有就表示default权限



==================================设计原则
明白了uml图怎么画后，我们就可以开始了解什么是软件设计原则了，软件设计有六大原则。
分别是：
单一职责原则、接口隔离原则、开闭原则、里氏替换原则、依赖倒置原则、迪米特法则

首先介绍一下单一职责原则，它的定义不易理解，它是这样定义的：一个类仅有一个引起它变化的原因。换句话讲就容易理解了：一个类应该只负责一项职责。下面我们看一下案例：
案例中我们定义了一个Report类，有几个方法：分别是生成报告：generateReport、保存到文件saveToFile、打印print，其实这种不合理的设计到处都有，最主要思想的就是职责划分。那一个符合单一原则的设计就像下面这样：
把报告的保存和报告的打印分别用一个类来实现。我们用ReportSaver来保存文件，用ReportPrinter来打印报告，在使用保存或者打印的地方直接用这两个类就好

那下面我们看下接口隔离原则，定义是这样：客户端不应该被迫依赖它不需要的接口；这里的接口，不局限于java中的interface关键字，泛指接口、类、方法等等客户端依赖的各种元素，强调的是客户端依赖的范围不能被强加一些不需要的。
咱们换种说法就好理解了：
一个接口设计的时候只包含实现类需要的方法。
下面我们看个案例，一种不符合接口隔离原则的设计，这里有个Animal，有吃、飞、游三个方法，分别有Dog和Fish去实现，但是由于Animal接口被强加了一些客户端不需要的方法，导致狗和鱼在实现接口的时候，Fly方法只能抛异常
那我们符合接口隔离原则的设计怎么做呢？其实就是把方法抽出来，比如eat，独立成Eater接口，swim独立成Swimmer，这样Dog就可以实现自己需要的吃和游的方法。

SRP VS LSP
那其实有时候这三个方法是有可能在一起的，比如要实现一只水鸟的接口，那就有可能吃、飞、游都有，按照单一职责原则，是可以把这三个方法写到一个类中的，但是按照接口隔离原则，这个类的interface还需要细分。
这里我们也可以看出来，单一职责原则强调的是类的职责，接口隔离原则重在接口的设计，SRP是把功能拆分成多个类，LSP呢，是把接口细分，让实现类可以灵活实现自己需要的接口。

下面介绍一下开闭原则，它的定义就非常清晰，面向扩展开放，面向修改关闭。什么意思呢？我们看个案例
这里有个面积计算器的类，支持输入形状计算面积，现在已经支持圆形和长方形了。因为都是用if、else写的，所以支持其他形状需要我们改变这段代码。
这就是面向修改开放了，我们要做到支持新功能的时候，原来的代码不发生变化或者发生微小变化，应该怎么做呢？
我们把计算面积的方法封装到形状里就行了，比如这里的Circle里有个获取面积的方法，公式写area里，π*r平方，面积计算器呢，还是支持传一个形状，但是计算面积的方法，交给形状了
这样，我们支持其他形状计算面积的方法时，只需要增加一个类，类中自行封装计算方法，原来的代码不受影响。

下面我们学习里氏替换原则，这个原则的定义是：如果对每一个类型为S的对象o1，都有类型为T的对
象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型S是类型T的子类型
哈哈，初次接触，非常难以理解，一般我们看另一种表述即可，说啊：所有引用基类的地方都必须能透明地使用其子类的对象而不会破坏原程序的正确性
举个例子就清楚了：
这里定义了一个Bird的类，让麻雀和企鹅去继承并实现其相关方法，但是企鹅不会飞，这里就抛一个异常，那么在main方法中，当这个Bird类
被new成企鹅的时候，就会报错，或者这么理解，当一个方法，比如A方法，中传入的参数就是Bird，A方法中调用了fly方法，这个A方法的Bird可以随意传任何Bird的子类吗？
我们这个案例不能吧？传入penguin就要报错呢，不符合：所有引用基类的地方都必须能透明地使用其子类的对象而不会破坏原程序的正确性
那我们符合里氏替换的做法是这样的：把麻雀和企鹅共同的方法抽成同一个接口，让麻雀再去实现一个新接口：FlyingBird，接口里就有fly方法
这样当我们用LspBird的地方都可以随意使用麻雀和企鹅了。

下面介绍一下依赖倒置原则，它的含义是：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。
其实这个原则咱们写业务代码时都在用，高层Controller一般会依赖一个service的接口，而不是直接依赖service的实现。我举个例子：
你看这个的DataProcessor直接依赖了FileManager，这就非常不合适，符合依赖倒置原则的写法应该是把文件保存抽象出一个接口
比如DataSaver，文件存储只是一方面，即使目前实现就一个，但是也应该依赖接口，方便以后扩展，这里举了一个数据库存储的类，让DataSever有了更多的一个选择
这里稍微解释下何为倒置？相比于传统，高层模块直接依赖低层模块，这个原则让低层模块依赖接口，高层模块依赖低层的接口，对于依赖的目标来说就是被倒置了。

下面介绍一下迪米特法则，这个法则说的是：一个类/模块对其他的类/模块了解得越少越好
这个法则，我们也看一个案例
这是一个电商系统的案例，有一个订单Order，一个顾客类Customer，一个地址类Address，订单想要获取邮编，所以依赖了顾客，顾客依赖了地址，顾客里有一个方法就是获取地址，
在通过顾客里的地址去获取邮编，那么在订单类中就会关联到地址这个类，实际上订单并不关心这个类，只需要邮编即可，所以我们符合迪米特法则的写法就是把获取邮编的方法封装起来
放到顾客类中，这样在order类中就不会用到Address了。减少了类对其他类的依赖

==================设计模式
在了解了UML图、六大设计原则后，我们终于可以学习具体的设计模式了。设计模式一共分为三大类，分别是：
行为型、创建型、结构型
首先聊一下创建型：


